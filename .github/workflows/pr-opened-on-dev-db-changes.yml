name: Pull Request Opened on Dev Branch w/ DB changes

on:
  # to manually trigger if I somehow missed an activity type
  workflow_dispatch:
  pull_request:
    # branches: [feat/no-ref/cicd-setup, test-pr]
    branches: [dev]
    types:
      [
        opened,
        synchronize,
        edited,
        reopened,
        ready_for_review,
        unlocked,
        review_requested,
        closed,
      ]
  # pull_request_target:
  #   branches: [dev]
  #   types: [closed]
  # paths: ['prisma/schema.prisma']
  # types: [opened, reopened, edited, submitted]
  # pull_request_review.submitted: run when an approving review is submitted for an opened pr
  # push:
  #   branches: [cicd-test]

# insert environment variable

env:
  GITHUB_PR_TITLE: ${{ github.event.pull_request.title }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  # not used in all jobs
  # GITHUB_PR_REFNUM: ${{ github.event.pull_request.number }}

  # cannot be accessed here since github environment specific
  # PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
  # PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
  # PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}

  # VERCEL_ENV: preview

jobs:
  changed-files:
    # enclosing context values in ${{ }} turns them into strings and strings are truthy
    if: github.event.pull_request.state != 'closed' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      ALL_CHANGES: ${{ steps.changes.outputs.ALL_CHANGES }}
      PRISMA_CHANGE: ${{ steps.changes.outputs.PRISMA_CHANGE }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      # compares latest commit sha of branch that triggered workflow (github.sha) and target of pull_request (base.sha)
      # github.sha depends on the event that triggered workflow
      # reference: https://dev.to/scienta/get-changed-files-in-github-actions-1p36
      - name: Get changed files
        id: changes
        run: |
          echo "ALL_CHANGES=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | xargs)" >> "${GITHUB_OUTPUT}"
          echo "PRISMA_CHANGE=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)" >> "${GITHUB_OUTPUT}"
      # - name: Set outputs as step-level env vars
      #   env:
      #     ALL_CHANGES: ${{ steps.changes.outputs.ALL_CHANGES }}
      #     PRISMA_CHANGE: ${{ steps.changes.outputs.PRISMA_CHANGE }}
      #   run: |
      #     echo "check env output - prisma: ${PRISMA_CHANGE} - all: ${ALL_CHANGES}"
      # # doesnt work since step-level env vars
      # - name: Get outputs stet as step-level env vars
      #   run: |
      #     echo "check env output - prisma: ${PRISMA_CHANGE} - all: ${ALL_CHANGES}"

      # echo "::set-output name=all::$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | xargs)"
      # echo "::set-output name=prisma::$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)"

      # no diff since github.sha is the same as head.sha
      # echo "changed files head - all files: $(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.head.sha }} ${{ github.sha }} | xargs)"
      # echo "changed files head - schema.prisma only: $(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.head.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)"

  # on opened pr targeting dev

  # with schema.prisma/db changes
  pscale-create-pr-branch-deploy-request:
    needs: changed-files
    if: github.event.pull_request.merged == false
    environment: preview # Github Environment
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_ORG_NAME: ${{ vars.PSCALE_ORG_NAME }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
      PSCALE_SRC_BRANCH: ${{ vars.PSCALE_SRC_BRANCH }}
      PSCALE_NEW_BRANCH: 'pr-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.ref }}'
      GITHUB_PR_REFNUM: ${{ github.event.pull_request.number }}
      VERCEL_ENV: ${{ vars.VERCEL_ENV }}
    outputs:
      DEPLOY_REQUEST_NUM: ${{ steps.create_deploy_request.outputs.NUMBER }}
      PRISMA_DATABASE_URL: ${{ steps.get_branch_password.outputs.PSCALE_CONN_STRING }}
      GITHUB_HEAD_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}
      # PSCALE_BRANCH_EXISTS: ${{ steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "with db changes? ${{ needs.changed-files.outputs.PRISMA_CHANGE }}"
          echo "all changes: ${{ needs.changed-files.outputs.ALL_CHANGES }}"
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PSCALE_NEW_BRANCH ${PSCALE_NEW_BRANCH}"
          echo "PSCALE_ORG_NAME ${PSCALE_ORG_NAME}"
          echo "VERCEL_ENV ${VERCEL_ENV}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref): ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref): ${{ github.event.pull_request.base.ref }}"
          echo "Current Branch (head.sha): ${{ github.event.pull_request.head.sha }}"
          echo "Target Branch (base.sha): ${{ github.event.pull_request.base.sha }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
          echo "GITHUB_REF: ${GITHUB_REF} & GITHUB_HEAD_REF: ${GITHUB_HEAD_REF}"
      - name: Planetscale Setup
        uses: planetscale/setup-pscale-action@v1
      - name: Check if Planetscale branch exists
        id: check_pscale_branch
        run: |
          echo "listing all branches on ORG:${PSCALE_ORG_NAME} DB:${PSCALE_DB_NAME}"

          pscale branch list ${PSCALE_DB_NAME} --org ${PSCALE_ORG_NAME} --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID}

          echo "Does BRANCH:${PSCALE_NEW_BRANCH} exist in DB:${PSCALE_DB_NAME}?"

          branchExists="pscale branch list ${PSCALE_DB_NAME} --org ${PSCALE_ORG_NAME} --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID} | grep ${PSCALE_NEW_BRANCH}"

          if eval $branchExists ; then
            echo "Pscale BRANCH:${PSCALE_NEW_BRANCH} exists..."
            echo "PSCALE_BRANCH_EXISTS=true" >> "${GITHUB_OUTPUT}"
          else
            echo "Pscale BRANCH:${PSCALE_NEW_BRANCH} does not exist..."
            echo "PSCALE_BRANCH_EXISTS=false" >> "${GITHUB_OUTPUT}"
          fi
        # eval "${branchExists} >> matching-db-branch.txt"
        # cat matching-db-branch.txt
      - name: Create Pscale Branch (if does not exist yet)
        if: steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS == 'false'
        run: |
          echo "Pscale Branch doesn't exist yet"
          echo "PSCALE_BRANCH_EXISTS: ${{ steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS }}"
          echo "1 ${{ steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS }}"
          echo "2 ${{ !steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS }}"
      - name: Don't Create Pscale Branch (already exists)
        if: steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS == 'true'
        run: |
          echo "Pscale Branch already exists"
          echo "PSCALE_BRANCH_EXISTS: ${{ steps.check_pscale_branch.outputs.PSCALE_BRANCH_EXISTS }}"
      # - name: Read db-branch-list.txt
      #   run: |
      #     code=$?
      #     if [ $code -eq 0 ] ; then
      #       cat db-branch-list.txt
      #       pscale_branch=`cat db-branch-list.txt`
      #       echo ${pscale_branch}
      #       exit 0
      #     else
      #       echo "There was an error"
      #       exit 1
      #     fi
      # check if failure() then create branch if not failure() dont create branch
      # if an error occurs, workflow stops running | even with if: always(), workflow still wont work? no way to execute the succeeding steps?  if need to separate it into another job but may not be a problem since can use if:() in steps...
      - name: If success
        if: ${{ success() }}
        run: |
          echo "steps.check_pscale_branch succeeded"
      - name: If failure
        if: ${{ failure() }}
        run: |
          echo "steps.check_pscale_branch failed"
      - name: Planetscale Create Branch
        if: needs.changed-files.outputs.PRISMA_CHANGE
        id: create_branch
        uses: planetscale/create-branch-action@v4
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
          from: ${{ env.PSCALE_SRC_BRANCH }}
          wait: true
      # - name: Get create branch output
      #   run: |
      #     echo "Branch create outputs: ${{ steps.create_branch.outputs }}"
      # per docs: no output variables
      # - name: Planetscale Branch Password Create & Prisma Connection String
      #   run: |
      #     pscale version
      #     pscale password create ${PSCALE_DB_NAME} "pr-${GITHUB_PR_REFNUM}" "ffph-dev-pr-${GITHUB_PR_REFNUM}-admin" --role admin --org ${PSCALE_ORG_NAME} -f json --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID} >pscale-branch-pword.txt 2>pscale-branch-pword-error.txt
      #     cat pscale-branch-pword.txt
      - name: Create branch password
        env:
          PWORD_ROLE: 'admin'
        uses: planetscale/create-branch-password-action@v3
        id: create_password
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
          role: ${PWORD_ROLE}
          name: 'ffph-dev-pr-${{ env.GITHUB_PR_REFNUM }}-${PWORD_ROLE}'
      - name: Get branch credentials
        id: get_branch_password
        run: |
          echo "Hostname: ${{ steps.create_password.outputs.hostname }}" \
          echo "Username: ${{ steps.create_password.outputs.username }}" \
          echo "Password: ${{ steps.create_password.outputs.password }}"
          echo "PSCALE_CONN_STRING=mysql://${{ steps.create_password.outputs.username }}:${{ steps.create_password.outputs.password }}@${{ steps.create_password.outputs.hostname }}/${PSCALE_DB_NAME}?sslaccept=strict"
          echo "PSCALE_CONN_STRING=mysql://${{ steps.create_password.outputs.username }}:${{ steps.create_password.outputs.password }}@${{ steps.create_password.outputs.hostname }}/${PSCALE_DB_NAME}?sslaccept=strict" >> "${GITHUB_OUTPUT}"
      - name: Install Vercel CLI
        run: npm install --global vercel@latest
      - name: Pull Vercel Environment Information
        run: vercel env pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
      - name: Check Values after vercel env pull
        run: |
          echo "${DATABASE_URL}"
          echo "${NEXTAUTH_URL}"
          echo "${NEXTAUTH_SECRET}"
          echo "${VERCEL_URL}"
          echo "${VERCEL_ENV}"
          echo "https://{VERCEL_URL}"
          echo "https://${VERCEL_URL}"
      # Better to build in Vercel so that it has access to System Environment Variables and no need to define NEXTAUTH_URL
      # reference: https://next-auth.js.org/configuration/options
      - name: Extract branch name
        id: extract_branch
        # shell: bash
        run: |
          echo "check GITHUB_HEAD_BRANCH: ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
          echo "GITHUB_HEAD_BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
        # https://stackoverflow.com/questions/58033366/how-to-get-the-current-branch-within-github-actions
      - name: Display branch name
        run: |
          echo "using GITHUB_HEAD_REF and GITHUB_REF: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}"
          echo "using pull_request event object: ${{ github.event.pull_request.head.sha }}"
      - name: Add Env Vars to Preview Deployment on branch w/ opened PR
        run: |
          echo ${PRISMA_DATABASE_URL} >> db-url.txt
          cat db-url.txt
          vercel env add DATABASE_URL ${VERCEL_ENV} ${{ steps.extract_branch.outputs.branch }} < db-url.txt --token=${{ secrets.VERCEL_TOKEN }}

      # get pscale connection string of newly created branch on ffph_dev
      # prisma db push before creating deploy request (pscale still works even though deploy request created first before "db push" changes)
      # create deploy request

      - name: Create a deploy request
        id: create_deploy_request
        uses: planetscale/create-deploy-request-action@v2
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
      - name: Get the deploy request number
        run: |
          echo "Deploy request number: ${{ steps.create_deploy_request.outputs.number }}"

      - name: With DB Changes
        if: needs.changed-files.outputs.PRISMA_CHANGE
        run: |
          echo "running step for with db changes"
      - name: Without DB Changes
        # converts output into String(Boolean) and then can be compared to 'false'
        # if: ${{ !needs.changed-files.outputs.PRISMA_CHANGE }} == 'false'
        # or check if empty string '' meaning no value | ! operator doesn't work at step-level conditional
        if: needs.changed-files.outputs.PRISMA_CHANGE == ''
        run: |
          echo "running step for no db changes"
  # vercel env add DATABASE_URL for the branch (ffph_dev main if no changes | ffph_dev pr-refnum iw w/changes)
  # vercel deploy

  # without schema.prisma/db changes
  without-db-changes:
    needs: changed-files
    if: github.event.pull_request.merged == false && !needs.changed-files.outputs.PRISMA_CHANGE
    environment: preview # Github Environment
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "with db changes? ${{ needs.changed-files.outputs.PRISMA_CHANGE }}"
          echo "all changes: ${{ needs.changed-files.outputs.ALL_CHANGES }}"
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref): ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref): ${{ github.event.pull_request.base.ref }}"
          echo "Current Branch (head.sha): ${{ github.event.pull_request.head.sha }}"
          echo "Target Branch (base.sha): ${{ github.event.pull_request.base.sha }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
      - name: Install Planetscale CLI
        run: |
          echo "installing planetscale cli"

  # on approved pr and merged branch into dev
  # approve deploy request
  # delete pr branch

  pscale-merge-pr-branch-approve-deploy-request:
    if: github.event.pull_request.merged == true
    environment: preview
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref) pull_request: ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref) pull_request: ${{ github.event.pull_request.base.ref }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
      - name: Approve Pscale Deploy Request
        run: |
          echo "Pull Request has been merged into Github Dev Branch"
          echo "approving pscale deploy request from pr branch into main branch on ffph_dev db"
      - name: Delete Pscale ffph_dev pr branch
        run: |
          echo "Deleting pr branch on ffph_dev db"

  # vercel-deploy-feat-with-opened-pr:
  #   environment: preview
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Check Env Values
  #       run: |
  #         echo ${GITHUB_PR_REFNUM}
  #         echo ${GITHUB_PR_TITLE}
  #         echo ${VERCEL_ORG_ID}
  #         echo ${VERCEL_PROJECT_ID}
  #         echo ${PSCALE_SRC_BRANCH}
  #     - name: Get code
  #       uses: actions/checkout@v3
  #     - name: Cache dependencies
  #       id: cache
  #       uses: actions/cache@v3
  #       with:
  #         path: ./node_modules
  #         key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
  #     - name: Install dependencies
  #       if: steps.cache.outputs.cache-hit != 'true'
  #       run: npm ci
  #     - name: Install Vercel CLI
  #       run: npm install --global vercel@latest
  #     # - name: Pull Vercel Environment Information
  #     #   run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
  #     # - name: Check Values after vercel env pull
  #     #   run: |
  #     #     echo "${DATABASE_URL}"
  #     #     echo "${NEXTAUTH_URL}"
  #     #     echo "${NEXTAUTH_SECRET}"
  #     #     echo $VERCEL_URL
  #     #     echo "${VERCEL_URL}"
  #     #     echo "${VERCEL_ENV}"
  #     #     echo "https://{VERCEL_URL}"
  #     #     echo "https://${VERCEL_URL}"
  #     # Better to build in Vercel so that it has access to System Environment Variables and no need to define NEXTAUTH_URL
  #     # reference: https://next-auth.js.org/configuration/options
  #     # - name: Build Project Artifacts
  #     #   run: npm run postinstall && vercel build --token=${{ secrets.VERCEL_TOKEN }}
  #     - name: Deploy Project to Vercel
  #       run: |
  #         vercel deploy --token=${{ secrets.VERCEL_TOKEN }} >deployment-url.txt 2>error.txt
  #         bash ./shell-scripts/vercel-check-deploy.sh
  #       # vercel deploy --token=${{ secrets.VERCEL_TOKEN }} > deployment-url.txt
  #       # echo "env.VERCEL_ENV ${{ env.VERCEL_ENV }}"
  #       # NEXTAUTH will produce error after deployment if using "vercel deploy --prebuilt", since VERCEL_URL (deployment url) not yet known during build step (previous step)
  #       # can only get VERCEL_URL after deploy
  #       # run: vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }}
  #     # - name: Extract branch name
  #     #   id: extract_branch
  #     #   # shell: bash
  #     #   run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
  #     #   # https://stackoverflow.com/questions/58033366/how-to-get-the-current-branch-within-github-actions
  #     # - name: Add Env Var to Preview Deployment on branch w/ opened PR
  #     #   run: |
  #     #     echo ${{ steps.extract_branch.outputs.branch }}
  #     #     vercel env add NEXTAUTH_URL preview ${{ steps.extract_branch.outputs.branch }} < deployment-url.txt --token=${{ secrets.VERCEL_TOKEN }}
  #     # remove env variable if already exists for branch
  #     # vercel env rm --yes NEXTAUTH_URL ${{ env.VERCEL_ENV }} ${{ steps.extract_branch.outputs.branch }} --token=${{ secrets.VERCEL_TOKEN }}
  #     # run: vercel env add [env-name] [environment=preview] [gitbranch=gh-actions-vars] < file
  #     # ref: https://vercel.com/docs/cli/env
  #     # need a bash script to check if NEXTAUTH_URL already defined for preview pr branch, then remove it if present otherwise proceed directly to adding it

  # # pscale create  branch: pr-refnum | on db: ffph_dev | uname: fractionfitness2021-bak
  # # pscale deploy request
  # # pscale get connection string and use in vercel deployment of feat-refnum-*

  # vercel-deploy-dev-after-merged-pr:
  #   if: github.event.pull_request.merged == true
  #   environment: preview
  #   needs: pscale-merge-pr-branch
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Check Env Values
  #       run: |
  #         echo ${GITHUB_PR_REFNUM}
  #         echo ${GITHUB_PR_TITLE}
  #         echo ${VERCEL_ORG_ID}
  #         echo ${VERCEL_PROJECT_ID}
  #         echo ${PSCALE_SRC_BRANCH}
  #     - name: Get code
  #       uses: actions/checkout@v3
  #     - name: Cache dependencies
  #       id: cache
  #       uses: actions/cache@v3
  #       with:
  #         path: ./node_modules
  #         key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
  #     - name: Install dependencies
  #       if: steps.cache.outputs.cache-hit != 'true'
  #       run: npm ci
  #     - name: Install Vercel CLI
  #       run: npm install --global vercel@latest
  #     - name: Deploy Project to Vercel
  #       run: |
  #         vercel deploy --token=${{ secrets.VERCEL_TOKEN }} >deployment-url.txt 2>error.txt
  #         bash ./shell-scripts/vercel-check-deploy.sh

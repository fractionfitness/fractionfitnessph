name: Pull Request on Feat into Dev

on:
  # to manually trigger if I somehow missed an activity type
  workflow_dispatch:
  pull_request:
    # branches: [feat/no-ref/cicd-setup, test-pr]
    branches: [dev]
    types:
      [
        opened,
        synchronize,
        edited,
        reopened,
        ready_for_review,
        unlocked,
        review_requested,
        closed,
      ]
  # synchronize - push commits to head branch
  # edited - when base ref on base branch changes for the pr
  # paths: ['prisma/schema.prisma'] # only run when the paths are included in commits
  # type: pull_request_review.submitted: run when an approving review is submitted for an opened pr

env:
  GITHUB_PR_TITLE: ${{ github.event.pull_request.title }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  PWORD_ROLE: 'admin'

  # not used in all jobs
  # GITHUB_PR_REFNUM: ${{ github.event.pull_request.number }}

  # cannot be accessed here since github environment specific
  # PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
  # PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
  # PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}

  # VERCEL_ENV: preview

jobs:
  get-scripts:
    # covers case when pull_requests are closed and not merged | pr is cancelled/closed w/o merging
    # succeeding job does not run if this job runs because their conditionals are mutually exclusive
    # need to get scripts so that branch and deploy request can be closed/deleted if pr is closed and head branch is not merged into base branch
    # separated from changed-files job to prevent checking out code with fetch-depth=0 and avoid getting changed files, if pr is cancelled
    # if pr is cancelled, just need to close pscale branch and deploy requests
    # if: github.event.pull_request.state == 'closed' && github.event.pull_request.merged == false
    if: false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Upload Planetscale Scripts Artifact
        uses: actions/upload-artifact@v3
        with:
          name: shell-scripts
          path: ./shell-scripts/

  # covers pull_requests that are not 'closed' OR pull_requests that are 'closed' and 'merged' into base branch (dev)
  changed-files:
    # needs ensures that this doesnt execute until 1st job is evaluated
    needs: get-scripts
    # enclosing context values in ${{ }} turns them into strings and strings are truthy
    # this job does not run if previous job was executed because their conditionals are mutually exclusive
    if: github.event.pull_request.state != 'closed' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      ALL_CHANGES: ${{ steps.changes.outputs.ALL_CHANGES }}
      DB_CHANGES: ${{ steps.changes.outputs.DB_CHANGES }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      # compares latest commit sha of branch that triggered workflow (github.sha) and target of pull_request (base.sha)
      # github.sha depends on the event that triggered workflow
      # reference: https://dev.to/scienta/get-changed-files-in-github-actions-1p36
      - name: Get changed files
        id: changes
        run: |
          echo "ALL_CHANGES=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | xargs)" >> "${GITHUB_OUTPUT}"
          echo "DB_CHANGES=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)" >> "${GITHUB_OUTPUT}"
      # - name: Set outputs as step-level env vars
      #   env:
      #     ALL_CHANGES: ${{ steps.changes.outputs.ALL_CHANGES }}
      #     DB_CHANGES: ${{ steps.changes.outputs.DB_CHANGES }}
      #   run: |
      #     echo "check env output - prisma: ${DB_CHANGES} - all: ${ALL_CHANGES}"
      # # doesnt work since step-level env vars
      # - name: Get outputs stet as step-level env vars
      #   run: |
      #     echo "check env output - prisma: ${DB_CHANGES} - all: ${ALL_CHANGES}"

      # deprecated
      # echo "::set-output name=all::$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | xargs)"
      # echo "::set-output name=prisma::$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)"

      # no diff since github.sha is the same as head.sha
      # echo "changed files head - all files: $(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.head.sha }} ${{ github.sha }} | xargs)"
      # echo "changed files head - schema.prisma only: $(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.head.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)"

      # still need to upload artifacts because previous job will not have been executed, if current job is running
      - name: Upload Planetscale Scripts Artifact
        uses: actions/upload-artifact@v3
        with:
          name: shell-scripts
          path: ./shell-scripts/

  # unmerged-closed-pr
  pscale-delete-branch:
    needs: changed-files
    # when PR is closed, branch should be deleted whether pr was merged or not
    # if PR is merged, deploy req should be checked if DR_APPROVED='Yes' && DR_STATE='open' && DR_DEPLOY_STATE='ready' && DR_DEPLOYABLE
    # this means, that the open DR for the pscale branch (linked to the PR) was already reviewed and approved, has db changes and ready for staging/deployment, and is deployable w/ no errors
    # this job should only run if there are db changes
    if: github.event.pull_request.state == 'closed' && needs.changed-files.outputs.DB_CHANGES
    runs-on: ubuntu-latest
    steps:
      - name: Download shell-scripts artifact
        uses: actions/download-artifact@v3
        with:
          name: shell-scripts
          path: ./shell-scripts/

      - name: Check if Planetscale branch exists
        id: branch_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/check-branch-exists.sh

          ./shell-scripts/pscale/check-branch-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}" "${PLANETSCALE_SERVICE_TOKEN_ID}" "${PLANETSCALE_SERVICE_TOKEN}"
          echo "step outputs: PSCALE_BRANCH_EXISTS"

      #  include in dr-exists script to run npm run db:reset to make sure all pr head branch db changes have been included in DR? or should that be the responsibility of vercel deploy for PRs before proceeding to pscale delete branch?
      - name: Check if Deploy Request exists
        # no need to check deploy req if pr is closed and unmerged and just proceed directly to branch deletion, since it will automatically be 'closed' (DR_STATE) when branch is deleted
        if: github.event.pull_request.merged == true
        id: dr_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/check-dr-exists.sh

          ./shell-scripts/pscale/check-dr-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}"

          echo "outputs: DR_EXISTS / DR_NUMBER / DR_BRANCH / DR_INTO_BRANCH / DR_APPROVED / DR_STATE / DR_DEPLOY_STATE / DR_DEPLOYABLE

      # should not happen since no PR merge should be done for a feat branch (w/ db changes) w/o a corresponding pscale branch and deploy request
      # if deploy request and branch does not exist, job should fail to prompt team to create them, have them approved, only then will the workflow restart
      # otherwise succeeding steps will still execute since no exit 1 code
      # - name: Create Deploy Request if non-existent???

      # CONTINUE HERE:
      # ISSUES:
      # need a husky script that checks commit messages and makes sure no | symbols used otherwise, we may gen an get an error in workflow is using echo with the git commit message
      # find out how to use continue-on-error, steps.step_id.outcome|conclusion | failure(), success(), always(), cancelled()
      # issues with my if conditionals | some steps should not execute if a preceeding step failed and vice versa
      # some of my steps should give out error codes of 1, like if no branch or deploy request
      # what happens when shell-scripts dont have exit codes??? if a deploy request/branch doesnt exist, will executing the shell script produce an exit code of 1?? produces an exit code of 0 unless i output exit codes in the shell script
      # need to output exit codes in shell scripts, especially when using pscale and vercel commands since I want to find out if the shell script succeeded and not have to keep using outputs to find out if a branch or DR exists, etc. | also useful since default behavior of workflow actions is to cancel job/steps if previous job/step failed
      # how to use xargs and awk vs grep
      # specific jobs should be factored out into reusable workflows

      # already have actions for create branch, deploy deploy request, create branch password, create deploy request action, setup pscale
      # might not need deploy deploy request script, or to check if branch or deploy request exists when creating these but might still need to check if exists when deploying & closing DR and closing branch
      # find out if deploy deploy request action also applies the changes or you need to "pscale deploy-request apply"
      # check out pscale helper scripts | but missing script for "deploy-request apply" since maybe its meant to be manually triggered and not automated, otherwise, why use gated deployments

      # combine script for check DR exists and approve into one
      #./shell-script/pscale/deploy-request.sh <check|deploy|apply> [args,...]
      # always append 2>&1 to the end of a pscale/vercel command inside of eval
      # always echo ${output}

      # DR should be approved prior to Deploy/Stage of DR
      - name: Approve Deploy Request
        id: dr_approval
        if: github.event.pull_request.merged == true && steps.dr_exists.outputs.DR_APPROVED == 'No' && steps.dr_exists.outputs.DR_STATE == 'open' && steps.dr_exists.outputs.DR_DEPLOY_STATE == 'ready' && steps.dr_exists.outputs.DR_DEPLOYABLE == 'Yes'
        run: |
          echo " pscale deploy-request review ffph_dev dr_num --approve "
          echo "DR_APPROVED=Yes" >> "${GITHUB_OUTPUT}"

      - name: Deploy or Stage Deploy Request & Apply Changes
        # prevents deployment of DR_APPROVED='No', DR_STATE='closed', DR_DEPLOY_STATE='no_changes|error|other states', DR_DEPLOYABLE='No'
        #  what happens if DR_APPROVED='Yes' in id=dr_exists???
        if: ${{ github.event.pull_request.merged == true && (steps.dr_approval.outputs.DR_APPROVED == 'Yes' || steps.dr_exists.outputs.DR_APPROVED == 'Yes' ) }}
        run: |
          echo " pscale deploy-request edit ffph_dev dr_num --auto-apply 'enable' && pscale deploy-request deploy ffph_dev dr_num "

      # NOTE: deployed changes will not be permanent (DR_DEPLOY_STATE=complete && DR_STATE=closed) until after schema-revert period is finished or is skipped

      # MOVE THIS TO THE TOP
      # pscale automatically closes DR when branch is deleted so no need to close it when pull_request.merged == false | just need to make sure branch is deleted
      - name: Pscale Delete Branch if PR is closed and Head Branch is unmerged into Base Branch
        if: github.event.pull_request.merged == false
        run: |
          echo "immediately delete for PRs that are closed and not merged"

      #  only delete branch when pr merge is true if:
      # ideally, we should wait until DR_APPROVED=Yes, DR_STATE=closed, and DR_DEPLOY_STATE=complete before deleting branch
      # how do I check if deploy/stage DR & apply changes have succeeded???
      # I think this should just be a separate workflow for this case, where it checks for the state, when a manual trigger (workflow_dispatch) is activated
      - name: Pscale Delete Branch if PR is closed and merged
        if: true
        run: |
          echo "this should be a manual trigger"

  pscale-create-branch-deploy-request:
    needs: changed-files
    # pull request is not yet merged && w/ db changes
    if: github.event.pull_request.merged == false && needs.changed-files.outputs.DB_CHANGES
    environment: preview # Github Environment
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_ORG_NAME: ${{ vars.PSCALE_ORG_NAME }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
      PSCALE_SRC_BRANCH: ${{ vars.PSCALE_SRC_BRANCH }}
      PSCALE_NEW_BRANCH: 'pr-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.ref }}'

      # will not interpolate the env var during "echo command" but not an issue as long as PSCALE_NEW_BRANCH_PWORD is used inside of ${{}} or "${}" (double quotes are required)
      # Display name for PSCALE_NEW_BRANCH_PWORD can only contain lowercase alphanumeric characters and dashes, and cannot start or end with a dash."
      PSCALE_NEW_BRANCH_PWORD: 'pr-${{ github.event.pull_request.number }}-${PWORD_ROLE}'
      GITHUB_PR_REFNUM: ${{ github.event.pull_request.number }}
      VERCEL_ENV: ${{ vars.VERCEL_ENV }}

    outputs:
      # PSCALE_DR_NUM: ${{ steps.create_deploy_request.outputs.NUMBER }}
      # GITHUB_HEAD_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}

      # secrets not allowed to be set in outputs | github actions will mask them or replace them as empty strings
      # PSCALE_CONN_STRING: ${{ steps.get_password.outputs.PSCALE_CONN_STRING }}

      PSCALE_BRANCH_EXISTS: ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}
      PSCALE_BRANCH_PWORD_EXISTS: ${{ steps.check_pword_exists.outputs.PSCALE_BRANCH_PWORD_EXISTS }}
      PSCALE_BRANCH_PWORD_CREATED: ${{ steps.get_password.outputs.PSCALE_BRANCH_PWORD_CREATED }}
      DB_CHANGES: ${{ needs.changed-files.outputs.DB_CHANGES }}

      # how to set if either has a value
      # these values may not be needed since no succeeding job (connected to this job) needs this
      # only steps in this job need these values
      PSCALE_DR_NUM: ${{ steps.create_deploy_request.outputs.NUMBER || steps.check_dr_exists.outputs.PSCALE_DR_NUM }}
      PSCALE_DR_STATE: ${{ steps.check_dr_exists.outputs.PSCALE_DR_STATE }}
      PSCALE_DR_DEPLOY_STATE: ${{ steps.check_dr_exists.outputs.PSCALE_DR_DEPLOY_STATE }}

    runs-on: ubuntu-latest

    steps:
      - name: Check Env Values
        run: |
          echo "with db changes? ${{ needs.changed-files.outputs.DB_CHANGES }}"
          echo "all changes: ${{ needs.changed-files.outputs.ALL_CHANGES }}"
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PSCALE_NEW_BRANCH ${PSCALE_NEW_BRANCH}"
          echo "PSCALE_NEW_BRANCH_PWORD: ${PSCALE_NEW_BRANCH_PWORD}"
          echo "PSCALE_ORG_NAME ${PSCALE_ORG_NAME}"
          echo "VERCEL_ENV ${VERCEL_ENV}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref): ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref): ${{ github.event.pull_request.base.ref }}"
          echo "Current Branch (head.sha): ${{ github.event.pull_request.head.sha }}"
          echo "Target Branch (base.sha): ${{ github.event.pull_request.base.sha }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
          echo "GITHUB_REF: ${GITHUB_REF} | GITHUB_HEAD_REF: ${GITHUB_HEAD_REF} | GITHUB_BASE_REF: ${GITHUB_BASE_REF}"
      - name: Planetscale Setup
        uses: planetscale/setup-pscale-action@v1

      # - name: Check if Planetscale branch exists
      #   id: check_branch_exists
      #   run: |
      #     echo "listing all branches on ORG:${PSCALE_ORG_NAME} DB:${PSCALE_DB_NAME}"
      #     pscale branch list ${PSCALE_DB_NAME} --org ${PSCALE_ORG_NAME} --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID}
      #     echo "Does BRANCH:${PSCALE_NEW_BRANCH} exist in DB:${PSCALE_DB_NAME}?"
      #     branchExists="pscale branch list ${PSCALE_DB_NAME} --org ${PSCALE_ORG_NAME} --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID} | grep ${PSCALE_NEW_BRANCH}"
      #     if eval $branchExists ; then
      #       echo "Pscale BRANCH:${PSCALE_NEW_BRANCH} exists..."
      #       echo "PSCALE_BRANCH_EXISTS=true" >> "${GITHUB_OUTPUT}"
      #     else
      #       echo "Pscale BRANCH:${PSCALE_NEW_BRANCH} does not exist..."
      #       echo "PSCALE_BRANCH_EXISTS=false" >> "${GITHUB_OUTPUT}"
      #     fi
      # eval "${branchExists} >> matching-db-branch.txt"
      # cat matching-db-branch.txt
      #
      # - name: Read matching-db-branch.txt
      #   run: |
      #     code=$?
      #     if [ $code -eq 0 ] ; then
      #       cat matching-db-branch.txt.txt
      #       pscale_branch=`cat matching-db-branch.txt`
      #       echo ${pscale_branch}
      #       exit 0
      #     else
      #       echo "There was an error"
      #       exit 1
      #     fi
      # check if previous step failed then create branch | if not failed, dont create branch
      # if an error occurs, workflow stops running | even with if: always(), workflow still wont work? no way to execute the succeeding steps?  if need to separate it into another job but may not be a problem since can use if:() in steps...
      #
      # - name: If success
      #   if: ${{ success() }}
      #   run: |
      #     echo "steps.check_branch_exists succeeded"
      #
      # - name: If failure
      #   if: ${{ failure() }}
      #   run: |
      #     echo "steps.check_branch_exists failed"
      # better solution to check branch exists | based on planetscale/create-branch-action@v4 script to check pscale branch
      #
      # - name: Checkout repository
      #   uses: actions/checkout@v3

      # use uploaded artifact instead of checking out repo
      - name: Download shell-scripts artifact
        uses: actions/download-artifact@v3
        with:
          name: shell-scripts
          path: ./shell-scripts/

      - name: Check if Planetscale branch exists
        id: check_branch_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/

          ./shell-scripts/pscale/check-branch-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}" "${PLANETSCALE_SERVICE_TOKEN_ID}" "${PLANETSCALE_SERVICE_TOKEN}"
          echo "step outputs: PSCALE_BRANCH_EXISTS"

        # still works even if pscale service token and id is not passed
        # ./shell-scripts/pscale/check-branch-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}"
        # chmod is needed anytime in a Dockerfile or downloading an artifact that needs to be executed

      - name: Create Pscale Branch (if does not exist yet)
        if: steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS == 'false'
        run: |
          echo "Pscale Branch doesn't exist yet"
          echo "PSCALE_BRANCH_EXISTS: ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"
          echo "1 ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"
          echo "2 ${{ !steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"

        # !steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS doesn't work coz its a string

      - name: Don't Create Pscale Branch (already exists)
        if: steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS == 'true'
        run: |
          echo "Pscale Branch already exists"
          echo "PSCALE_BRANCH_EXISTS: ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"

      - name: Planetscale Create Branch
        if: steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS == 'false'
        uses: planetscale/create-branch-action@v4
        with:
          check_exists: true # does not create if branch exists | no outputs so succeeding jobs can't check if branch already exists (unless we modify this action) so we still need to do the previous steps
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
          from: ${{ env.PSCALE_SRC_BRANCH }}
          wait: true
      # per docs: no output variables
      # - name: Planetscale Branch Password Create & Prisma Connection String
      #   run: |
      #     pscale version
      #     pscale password create ${PSCALE_DB_NAME} "pr-${GITHUB_PR_REFNUM}" "ffph-dev-pr-${GITHUB_PR_REFNUM}-admin" --role admin --org ${PSCALE_ORG_NAME} -f json --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID} >pscale-branch-pword.txt 2>pscale-branch-pword-error.txt
      #     cat pscale-branch-pword.txt
      - name: Check if Planetscale branch password exists
        id: check_pword_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/check-pword-exists.sh

          ./shell-scripts/pscale/check-pword-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}" ${PSCALE_NEW_BRANCH_PWORD}

          echo "step outputs: PSCALE_BRANCH_PWORD_EXISTS"

        # $1 DB $2 BRANCH $3 PWORD_NAME
        # still works even if pscale service token and id is not passed
        # ./shell-scripts/pscale/check-pword-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}"
        # chmod is needed anytime in a Dockerfile or downloading an artifact that needs to be executed

      - name: Create Planetscale branch password
        # branch pword doesn't exist yet
        if: steps.check_pword_exists.outputs.PSCALE_BRANCH_PWORD_EXISTS == 'false'
        # env:
        #   PWORD_ROLE: 'admin'
        uses: planetscale/create-branch-password-action@v3
        id: create_password
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
          role: ${PWORD_ROLE}
          name: ${{ env.PSCALE_NEW_BRANCH_PWORD }}
          # name: 'ffph-dev-pr-${{ env.GITHUB_PR_REFNUM }}-${PWORD_ROLE}'

      - name: Get Planetscale branch credentials
        id: get_password
        # only run if pscale branch password was created in previous step | password has a value or is not an empty string
        if: steps.create_password.outputs.password
        # cannot use secrets directly in run cmds since gh actions masks anything that looks like a secret with **** | just set them to step-level/job-level env variables first
        env:
          HOSTNAME: ${{ steps.create_password.outputs.hostname }}
          USERNAME: ${{ steps.create_password.outputs.username }}
          PASSWORD: ${{ steps.create_password.outputs.password }}
        shell: bash
        run: |
          echo "mysql://${USERNAME}:${PASSWORD}@${HOSTNAME}/${PSCALE_DB_NAME}?sslaccept=strict" | tee -a "pscale-conn-string.txt"
          echo "PSCALE_BRANCH_PWORD_CREATED=true" >> "${GITHUB_OUTPUT}"

      # "tee -a" appends value to multiple files
      # cannot set secret as output as github actions will mask it with ****
      # echo "${PSCALE_CONN_STRING}" | tee -a "${GITHUB_OUTPUT}" "pscale-conn-string.txt"

      # should not upload if no branch credentials
      - name: Upload Planetscale Connection String
        # if pscale branch password was created | don't use steps.check_pword_exists.outputs.PSCALE_BRANCH_PWORD_EXISTS since cannot get the conn string there
        # better to check so that this skip may be skipped | step still succeeds if file is non-existent it just won't upload anything
        if: steps.create_password.outputs.password
        uses: actions/upload-artifact@v3
        with:
          name: pscale-conn-string
          path: pscale-conn-string.txt

      - name: Check if Planetscale branch deploy request exists
        id: check_dr_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/check-dr-exists.sh

          ./shell-scripts/pscale/check-dr-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}"
          echo "step outputs: PSCALE_BRANCH_PWORD_EXISTS"

      - name: Create branch deploy request
        # create if, deploy request for specified branch is non-existent OR deploy request exists but is "closed"
        if: steps.check_dr_exists.outputs.PSCALE_DR_EXISTS == 'false' || steps.check_dr_exists.outputs.PSCALE_DR_STATE == 'closed'
        id: create_deploy_request
        uses: planetscale/create-deploy-request-action@v2
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}

      - name: Get branch deploy request info
        run: |
          echo "Deploy request number: ${{ steps.create_deploy_request.outputs.number }}"
          echo "using steps.check_dr_exists outputs PSCALE_DR_NUM: ${{ steps.check_dr_exists.outputs.PSCALE_DR_NUM }}"
          echo "using steps.check_dr_exists outputs PSCALE_DR_STATE: ${{ steps.check_dr_exists.outputs.PSCALE_DR_STATE }}"
          echo "using steps.check_dr_exists outputs PSCALE_DR_DEPLOY_STATE: ${{ steps.check_dr_exists.outputs.PSCALE_DR_DEPLOY_STATE }}"
          echo "create_deploy_request || check_dr_exists DR number: ${{ steps.create_deploy_request.outputs.number || steps.check_dr_exists.outputs.PSCALE_DR_NUM}}"

      - name: With DB Changes
        if: needs.changed-files.outputs.DB_CHANGES
        run: |
          echo "running step for with db changes"

      - name: Without DB Changes
        # converts output into String(Boolean) and then can be compared to 'false'
        # if: ${{ !needs.changed-files.outputs.DB_CHANGES }} == 'false'
        # or check if empty string '' meaning no value | ! operator doesn't work at step-level conditional
        if: needs.changed-files.outputs.DB_CHANGES == ''
        run: |
          echo "running step for no db changes"

  vercel-deploy-pr-feat-dev:
    needs: pscale-create-branch-deploy-request
    # pull request is not yet merged && w/ db changes
    if: github.event.pull_request.merged == false && needs.pscale-create-branch-deploy-request.outputs.DB_CHANGES
    environment: preview # Github Environment
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ENV: ${{ vars.VERCEL_ENV }}
      PSCALE_DR_NUM: ${{ needs.pscale-create-branch-deploy-request.outputs.PSCALE_DR_NUM }}
      PSCALE_BRANCH_EXISTS: ${{ needs.pscale-create-branch-deploy-request.outputs.PSCALE_BRANCH_EXISTS }}

      # no longer using outputs for connection string since it is a secret
      # PRISMA_DATABASE_URL: ${{ needs.pscale-create-branch-deploy-request.outputs.PSCALE_CONN_STRING }}
    outputs:
      GITHUB_HEAD_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}
      GITHUB_BASE_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_BASE_BRANCH }}
    runs-on: ubuntu-latest
    steps:
      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment Variables
        run: vercel env pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Check Values after vercel env pull
        run: |
          echo "${DATABASE_URL}"
          echo "${NEXTAUTH_URL}"
          echo "${NEXTAUTH_SECRET}"
          echo "${VERCEL_URL}"
          echo "${VERCEL_ENV}"
          echo "https://{VERCEL_URL}"
          echo "https://${VERCEL_URL}"

        # Better to build in Vercel so that it has access to System Environment Variables and no need to define NEXTAUTH_URL
        # reference: https://next-auth.js.org/configuration/options

      - name: Extract branch name
        id: extract_branch
        # shell: bash
        run: |
          echo "check GITHUB_HEAD_BRANCH: ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
          echo "GITHUB_HEAD_BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT

          echo "check GITHUB_BASE_BRANCH: ${GITHUB_BASE_REF}"
          echo "GITHUB_BASE_BRANCH=${GITHUB_BASE_REF}" >> $GITHUB_OUTPUT

        # https://stackoverflow.com/questions/58033366/how-to-get-the-current-branch-within-github-actions

      - name: Display branches
        run: |
          echo "using GITHUB_HEAD_REF and GITHUB_REF: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}"
          echo "using pull_request event: GITHUB_HEAD_REF: ${{ github.event.pull_request.head.ref }}"
          echo "using GITHUB_BASE_REF: ${{ steps.extract_branch.outputs.GITHUB_BASE_BRANCH }}"
          echo "using pull_request event: GITHUB_BASE_REF: ${{ github.event.pull_request.base.ref }}"
          echo "check '\${GITHUB_HEAD_REF:-\${GITHUB_REF#refs/heads/}}' "
          echo "GITHUB_HEAD_BRANCH: ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
          echo "GITHUB_REF: ${GITHUB_REF} | GITHUB_HEAD_REF: ${GITHUB_HEAD_REF} | GITHUB_BASE_REF: ${GITHUB_BASE_REF}"

      # only execute if artifact exists | how to check if artifact exists?
      - name: Download Planetscale connection string
        # temporary solution
        if: needs.pscale-create-branch-deploy-request.outputs.PSCALE_BRANCH_PWORD_CREATED == 'true'
        uses: actions/download-artifact@v3
        with:
          name: pscale-conn-string
          path: ./

      # only execute if file exists | how to check??? maybe use ls
      - name: Add Env Vars to Preview Deployment on branch w/ opened PR
        if: needs.pscale-create-branch-deploy-request.outputs.PSCALE_BRANCH_PWORD_CREATED == 'true'
        run: |
          vercel env add --token="${VERCEL_TOKEN}" DATABASE_URL "${VERCEL_ENV}" ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }} < "pscale-conn-string.txt"

        # alternative to above command
        # cat "pscale-conn-string.txt" | vercel env add --token="${VERCEL_TOKEN}" DATABASE_URL "${VERCEL_ENV}" ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}

        # alternative to above command
        # cat "pscale-conn-string.txt" | vercel env add --token=${{ env.VERCEL_TOKEN }} DATABASE_URL "${VERCEL_ENV}" ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}

        # echo ${PRISMA_DATABASE_URL} >> db-url.txt
        # cat db-url.txt
        # vercel env add DATABASE_URL ${VERCEL_ENV} ${{ steps.extract_branch.outputs.GITHUB_BASE_BRANCH }} < db-url.txt --token=${{ secrets.VERCEL_TOKEN }}

  # get pscale connection string of newly created branch on ffph_dev
  # prisma db push before creating deploy request (pscale still works even though deploy request created first before "db push" changes)
  # create deploy request

  # vercel env add DATABASE_URL for the branch (ffph_dev main if no changes | ffph_dev pr-refnum iw w/changes)
  # vercel deploy

  # without schema.prisma/db changes
  without-db-changes:
    needs: changed-files
    if: github.event.pull_request.merged == false && !needs.changed-files.outputs.DB_CHANGES
    environment: preview # Github Environment
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "with db changes? ${{ needs.changed-files.outputs.DB_CHANGES }}"
          echo "all changes: ${{ needs.changed-files.outputs.ALL_CHANGES }}"
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref): ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref): ${{ github.event.pull_request.base.ref }}"
          echo "Current Branch (head.sha): ${{ github.event.pull_request.head.sha }}"
          echo "Target Branch (base.sha): ${{ github.event.pull_request.base.sha }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
      - name: Install Planetscale CLI
        run: |
          echo "installing planetscale cli"

  # on approved pr and merged branch into dev
  # approve deploy request
  # delete pr branch

  pscale-merge-pr-branch-approve-deploy-request:
    #  dont execute yet
    if: github.event.pull_request.merged == true && false
    environment: preview
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref) pull_request: ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref) pull_request: ${{ github.event.pull_request.base.ref }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
      - name: Approve Pscale Deploy Request
        run: |
          echo "Pull Request has been merged into Github Dev Branch"
          echo "approving pscale deploy request from pr branch into main branch on ffph_dev db"
      - name: Delete Pscale ffph_dev pr branch
        run: |
          echo "Deleting pr branch on ffph_dev db"

          # vercel-deploy-feat-with-opened-pr:
          #   environment: preview
          #   runs-on: ubuntu-latest
          #   steps:
          #     - name: Check Env Values
          #       run: |
          #         echo ${GITHUB_PR_REFNUM}
          #         echo ${GITHUB_PR_TITLE}
          #         echo ${VERCEL_ORG_ID}
          #         echo ${VERCEL_PROJECT_ID}
          #         echo ${PSCALE_SRC_BRANCH}
          #     - name: Get code
          #       uses: actions/checkout@v3
          #     - name: Cache dependencies
          #       id: cache
          #       uses: actions/cache@v3
          #       with:
          #         path: ./node_modules
          #         key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
          #     - name: Install dependencies
          #       if: steps.cache.outputs.cache-hit != 'true'
          #       run: npm ci
          #     - name: Install Vercel CLI
          #       run: npm install --global vercel@latest
          #     # - name: Pull Vercel Environment Information
          #     #   run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
          #     # - name: Check Values after vercel env pull
          #     #   run: |
          #     #     echo "${DATABASE_URL}"
          #     #     echo "${NEXTAUTH_URL}"
          #     #     echo "${NEXTAUTH_SECRET}"
          #     #     echo $VERCEL_URL
          #     #     echo "${VERCEL_URL}"
          #     #     echo "${VERCEL_ENV}"
          #     #     echo "https://{VERCEL_URL}"
          #     #     echo "https://${VERCEL_URL}"
          #     # Better to build in Vercel so that it has access to System Environment Variables and no need to define NEXTAUTH_URL
          #     # reference: https://next-auth.js.org/configuration/options
          #     # - name: Build Project Artifacts
          #     #   run: npm run postinstall && vercel build --token=${{ secrets.VERCEL_TOKEN }}
          #     - name: Deploy Project to Vercel
          #       run: |
          #         vercel deploy --token=${{ secrets.VERCEL_TOKEN }} >deployment-url.txt 2>error.txt
          #         bash ./shell-scripts/vercel/check-deploy.sh
          #       # vercel deploy --token=${{ secrets.VERCEL_TOKEN }} > deployment-url.txt
          #       # echo "env.VERCEL_ENV ${{ env.VERCEL_ENV }}"
          #       # NEXTAUTH will produce error after deployment if using "vercel deploy --prebuilt", since VERCEL_URL (deployment url) not yet known during build step (previous step)
          #       # can only get VERCEL_URL after deploy
          #       # run: vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }}
          #     # - name: Extract branch name
          #     #   id: extract_branch
          #     #   # shell: bash
          #     #   run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
          #     #   # https://stackoverflow.com/questions/58033366/how-to-get-the-current-branch-within-github-actions
          #     # - name: Add Env Var to Preview Deployment on branch w/ opened PR
          #     #   run: |
          #     #     echo ${{ steps.extract_branch.outputs.branch }}
          #     #     vercel env add NEXTAUTH_URL preview ${{ steps.extract_branch.outputs.branch }} < deployment-url.txt --token=${{ secrets.VERCEL_TOKEN }}
          #     # remove env variable if already exists for branch
          #     # vercel env rm --yes NEXTAUTH_URL ${{ env.VERCEL_ENV }} ${{ steps.extract_branch.outputs.branch }} --token=${{ secrets.VERCEL_TOKEN }}
          #     # run: vercel env add [env-name] [environment=preview] [gitbranch=gh-actions-vars] < file
          #     # ref: https://vercel.com/docs/cli/env
          #     # need a bash script to check if NEXTAUTH_URL already defined for preview pr branch, then remove it if present otherwise proceed directly to adding it

          # # pscale create  branch: pr-refnum | on db: ffph_dev | uname: fractionfitness2021-bak
          # # pscale deploy request
          # # pscale get connection string and use in vercel deployment of feat-refnum-*

          # vercel-deploy-dev-after-merged-pr:
          #   if: github.event.pull_request.merged == true
          #   environment: preview
          #   needs: pscale-merge-pr-branch
          #   runs-on: ubuntu-latest
          #   steps:
          #     - name: Check Env Values
          #       run: |
          #         echo ${GITHUB_PR_REFNUM}
          #         echo ${GITHUB_PR_TITLE}
          #         echo ${VERCEL_ORG_ID}
          #         echo ${VERCEL_PROJECT_ID}
          #         echo ${PSCALE_SRC_BRANCH}
          #     - name: Get code
          #       uses: actions/checkout@v3
          #     - name: Cache dependencies
          #       id: cache
          #       uses: actions/cache@v3
          #       with:
          #         path: ./node_modules
          #         key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
          #     - name: Install dependencies
          #       if: steps.cache.outputs.cache-hit != 'true'
          #       run: npm ci
          #     - name: Install Vercel CLI
          #       run: npm install --global vercel@latest
          #     - name: Deploy Project to Vercel
          #       run: |
          #         vercel deploy --token=${{ secrets.VERCEL_TOKEN }} >deployment-url.txt 2>error.txt
          #         bash ./shell-scripts/vercel/check-deploy.sh

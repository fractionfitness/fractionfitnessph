name: Pull Request on Feat into Dev

on:
  # to manually trigger if I somehow missed an activity type
  workflow_dispatch:
  pull_request:
    # branches: [feat/no-ref/cicd-setup, test-pr]
    branches: [dev]
    types:
      [
        opened,
        synchronize,
        edited,
        reopened,
        ready_for_review,
        unlocked,
        review_requested,
        closed,
      ]
  # paths: ['prisma/schema.prisma'] # only run when the paths are included in commits
  # type: pull_request_review.submitted: run when an approving review is submitted for an opened pr

env:
  GITHUB_PR_TITLE: ${{ github.event.pull_request.title }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  PWORD_ROLE: 'admin'

  # not used in all jobs
  # GITHUB_PR_REFNUM: ${{ github.event.pull_request.number }}

  # cannot be accessed here since github environment specific
  # PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
  # PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
  # PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}

  # VERCEL_ENV: preview

jobs:
  changed-files:
    # enclosing context values in ${{ }} turns them into strings and strings are truthy
    if: github.event.pull_request.state != 'closed' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      ALL_CHANGES: ${{ steps.changes.outputs.ALL_CHANGES }}
      PRISMA_CHANGE: ${{ steps.changes.outputs.PRISMA_CHANGE }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      # compares latest commit sha of branch that triggered workflow (github.sha) and target of pull_request (base.sha)
      # github.sha depends on the event that triggered workflow
      # reference: https://dev.to/scienta/get-changed-files-in-github-actions-1p36
      - name: Get changed files
        id: changes
        run: |
          echo "ALL_CHANGES=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | xargs)" >> "${GITHUB_OUTPUT}"
          echo "PRISMA_CHANGE=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)" >> "${GITHUB_OUTPUT}"
      # - name: Set outputs as step-level env vars
      #   env:
      #     ALL_CHANGES: ${{ steps.changes.outputs.ALL_CHANGES }}
      #     PRISMA_CHANGE: ${{ steps.changes.outputs.PRISMA_CHANGE }}
      #   run: |
      #     echo "check env output - prisma: ${PRISMA_CHANGE} - all: ${ALL_CHANGES}"
      # # doesnt work since step-level env vars
      # - name: Get outputs stet as step-level env vars
      #   run: |
      #     echo "check env output - prisma: ${PRISMA_CHANGE} - all: ${ALL_CHANGES}"

      # deprecated
      # echo "::set-output name=all::$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | xargs)"
      # echo "::set-output name=prisma::$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)"

      # no diff since github.sha is the same as head.sha
      # echo "changed files head - all files: $(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.head.sha }} ${{ github.sha }} | xargs)"
      # echo "changed files head - schema.prisma only: $(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.head.sha }} ${{ github.sha }} | grep schema.prisma$ | xargs)"

      - name: Upload Planetscale Scripts Artifact?
        # if there are DB Schema Changes
        if: steps.changes.outputs.PRISMA_CHANGE
        run: |
          echo "upload pscale scripts as artifact"
      - name: Upload Planetscale Scripts Artifact
        # if there are DB Schema Changes
        if: steps.changes.outputs.PRISMA_CHANGE
        uses: actions/upload-artifact@v3
        with:
          name: pscale-scripts
          path: ./shell-scripts/pscale/

      - name: Vercel Scripts Artifact?
        # pull request is not yet merged
        if: github.event.pull_request.merged == false
        run: |
          echo "upload vercel scripts as artifact"
      - name: Upload Vercel Scripts Artifact
        # pull request is not yet merged
        if: github.event.pull_request.merged == false
        uses: actions/upload-artifact@v3
        with:
          name: vercel-scripts
          path: ./shell-scripts/vercel/

  pscale-create-branch-deploy-request:
    needs: changed-files
    # pull request is not yet merged && w/ db changes
    if: github.event.pull_request.merged == false && needs.changed-files.outputs.PRISMA_CHANGE
    environment: preview # Github Environment
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_ORG_NAME: ${{ vars.PSCALE_ORG_NAME }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
      PSCALE_SRC_BRANCH: ${{ vars.PSCALE_SRC_BRANCH }}
      PSCALE_NEW_BRANCH: 'pr-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.ref }}'
      PSCALE_NEW_BRANCH_PWORD: 'ffph-dev-pr-${{ github.event.pull_request.number }}-${PWORD_ROLE}'
      GITHUB_PR_REFNUM: ${{ github.event.pull_request.number }}
      VERCEL_ENV: ${{ vars.VERCEL_ENV }}
    outputs:
      DEPLOY_REQUEST_NUM: ${{ steps.create_deploy_request.outputs.NUMBER }}
      PRISMA_DATABASE_URL: ${{ steps.get_password.outputs.PSCALE_CONN_STRING }}
      # GITHUB_HEAD_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}
      PSCALE_CONN_STRING: ${{ steps.get_password.outputs.PSCALE_CONN_STRING }}
      PSCALE_BRANCH_EXISTS: ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}
      PSCALE_BRANCH_PWORD_EXISTS: ${{ steps.check_pword_exists.outputs.PSCALE_BRANCH_PWORD_EXISTS }}
      PRISMA_CHANGE: ${{ needs.changed-files.outputs.PRISMA_CHANGE }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "with db changes? ${{ needs.changed-files.outputs.PRISMA_CHANGE }}"
          echo "all changes: ${{ needs.changed-files.outputs.ALL_CHANGES }}"
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PSCALE_NEW_BRANCH ${PSCALE_NEW_BRANCH}"
          echo "PSCALE_NEW_BRANCH_PWORD_NAME: ${PSCALE_NEW_BRANCH_PWORD_NAME}"
          echo "PSCALE_ORG_NAME ${PSCALE_ORG_NAME}"
          echo "VERCEL_ENV ${VERCEL_ENV}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref): ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref): ${{ github.event.pull_request.base.ref }}"
          echo "Current Branch (head.sha): ${{ github.event.pull_request.head.sha }}"
          echo "Target Branch (base.sha): ${{ github.event.pull_request.base.sha }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
          echo "GITHUB_REF: ${GITHUB_REF} & GITHUB_HEAD_REF: ${GITHUB_HEAD_REF}"
      - name: Planetscale Setup
        uses: planetscale/setup-pscale-action@v1

      # - name: Check if Planetscale branch exists
      #   id: check_branch_exists
      #   run: |
      #     echo "listing all branches on ORG:${PSCALE_ORG_NAME} DB:${PSCALE_DB_NAME}"
      #     pscale branch list ${PSCALE_DB_NAME} --org ${PSCALE_ORG_NAME} --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID}
      #     echo "Does BRANCH:${PSCALE_NEW_BRANCH} exist in DB:${PSCALE_DB_NAME}?"
      #     branchExists="pscale branch list ${PSCALE_DB_NAME} --org ${PSCALE_ORG_NAME} --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID} | grep ${PSCALE_NEW_BRANCH}"
      #     if eval $branchExists ; then
      #       echo "Pscale BRANCH:${PSCALE_NEW_BRANCH} exists..."
      #       echo "PSCALE_BRANCH_EXISTS=true" >> "${GITHUB_OUTPUT}"
      #     else
      #       echo "Pscale BRANCH:${PSCALE_NEW_BRANCH} does not exist..."
      #       echo "PSCALE_BRANCH_EXISTS=false" >> "${GITHUB_OUTPUT}"
      #     fi
      # eval "${branchExists} >> matching-db-branch.txt"
      # cat matching-db-branch.txt
      #
      # - name: Read matching-db-branch.txt
      #   run: |
      #     code=$?
      #     if [ $code -eq 0 ] ; then
      #       cat matching-db-branch.txt.txt
      #       pscale_branch=`cat matching-db-branch.txt`
      #       echo ${pscale_branch}
      #       exit 0
      #     else
      #       echo "There was an error"
      #       exit 1
      #     fi
      # check if previous step failed then create branch | if not failed, dont create branch
      # if an error occurs, workflow stops running | even with if: always(), workflow still wont work? no way to execute the succeeding steps?  if need to separate it into another job but may not be a problem since can use if:() in steps...
      #
      # - name: If success
      #   if: ${{ success() }}
      #   run: |
      #     echo "steps.check_branch_exists succeeded"
      #
      # - name: If failure
      #   if: ${{ failure() }}
      #   run: |
      #     echo "steps.check_branch_exists failed"
      # better solution to check branch exists | based on planetscale/create-branch-action@v4 script to check pscale branch
      #
      # - name: Checkout repository
      #   uses: actions/checkout@v3

      # use uploaded artifact instead of checking out repo
      - name: Download pscale-scripts artifact
        uses: actions/download-artifact@v3
        with:
          name: pscale-scripts
          path: ./shell-scripts/pscale/

      - name: Check if Planetscale branch exists
        id: check_branch_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/

          ./shell-scripts/pscale/check-branch-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}" "${PLANETSCALE_SERVICE_TOKEN_ID}" "${PLANETSCALE_SERVICE_TOKEN}"
          echo "step outputs: PSCALE_BRANCH_EXISTS"

        # still works even if pscale service token and id is not passed
        # ./shell-scripts/pscale/check-branch-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}"
        # chmod is needed anytime in a Dockerfile or downloading an artifact that needs to be executed

      - name: Create Pscale Branch (if does not exist yet)
        if: steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS == 'false'
        run: |
          echo "Pscale Branch doesn't exist yet"
          echo "PSCALE_BRANCH_EXISTS: ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"
          echo "1 ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"
          echo "2 ${{ !steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"

        # !steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS doesn't work coz its a string

      - name: Don't Create Pscale Branch (already exists)
        if: steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS == 'true'
        run: |
          echo "Pscale Branch already exists"
          echo "PSCALE_BRANCH_EXISTS: ${{ steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS }}"

      - name: Planetscale Create Branch
        if: steps.check_branch_exists.outputs.PSCALE_BRANCH_EXISTS == 'false'
        uses: planetscale/create-branch-action@v4
        with:
          check_exists: true # does not create if branch exists | no outputs so succeeding jobs can't check if branch already exists (unless we modify this action) so we still need to do the previous steps
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
          from: ${{ env.PSCALE_SRC_BRANCH }}
          wait: true
      # per docs: no output variables
      # - name: Planetscale Branch Password Create & Prisma Connection String
      #   run: |
      #     pscale version
      #     pscale password create ${PSCALE_DB_NAME} "pr-${GITHUB_PR_REFNUM}" "ffph-dev-pr-${GITHUB_PR_REFNUM}-admin" --role admin --org ${PSCALE_ORG_NAME} -f json --service-token ${PLANETSCALE_SERVICE_TOKEN} --service-token-id ${PLANETSCALE_SERVICE_TOKEN_ID} >pscale-branch-pword.txt 2>pscale-branch-pword-error.txt
      #     cat pscale-branch-pword.txt
      - name: Check if Planetscale branch password exists
        id: check_pword_exists
        run: |
          chmod -R +x ./shell-scripts/pscale/check-pword-exists.sh

          ./shell-scripts/pscale/check-pword-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}" "${PSCALE_NEW_BRANCH_PWORD}"

          echo "step outputs: PSCALE_BRANCH_PWORD_EXISTS"

        # $1 DB $2 BRANCH $3 PWORD_NAME
        # still works even if pscale service token and id is not passed
        # ./shell-scripts/pscale/check-pword-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_NEW_BRANCH}" "${PSCALE_ORG_NAME}"
        # chmod is needed anytime in a Dockerfile or downloading an artifact that needs to be executed

      - name: Create branch password
        # branch pword doesn't exist yet
        if: steps.check_pword_exists.outputs.PSCALE_BRANCH_PWORD_EXISTS == 'false'
        # env:
        #   PWORD_ROLE: 'admin'
        uses: planetscale/create-branch-password-action@v3
        id: create_password
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}
          role: ${PWORD_ROLE}
          name: ${{ env.PSCALE_NEW_BRANCH_PWORD }}
          # name: 'ffph-dev-pr-${{ env.GITHUB_PR_REFNUM }}-${PWORD_ROLE}'

      - name: Get branch credentials
        id: get_password
        run: |
          echo "Hostname: ${{ steps.create_password.outputs.hostname }}" \
          echo "Username: ${{ steps.create_password.outputs.username }}" \
          echo "Password: ${{ steps.create_password.outputs.password }}"
          echo "PSCALE_CONN_STRING=mysql://${{ steps.create_password.outputs.username }}:${{ steps.create_password.outputs.password }}@${{ steps.create_password.outputs.hostname }}/${PSCALE_DB_NAME}?sslaccept=strict"
          echo "PSCALE_CONN_STRING=mysql://${{ steps.create_password.outputs.username }}:${{ steps.create_password.outputs.password }}@${{ steps.create_password.outputs.hostname }}/${PSCALE_DB_NAME}?sslaccept=strict" >> "${GITHUB_OUTPUT}"

      - name: Create a deploy request
        id: create_deploy_request
        uses: planetscale/create-deploy-request-action@v2
        with:
          org_name: ${{ env.PSCALE_ORG_NAME }}
          database_name: ${{ env.PSCALE_DB_NAME }}
          branch_name: ${{ env.PSCALE_NEW_BRANCH }}

      - name: Get the deploy request number
        run: |
          echo "Deploy request number: ${{ steps.create_deploy_request.outputs.number }}"

      - name: With DB Changes
        if: needs.changed-files.outputs.PRISMA_CHANGE
        run: |
          echo "running step for with db changes"

      - name: Without DB Changes
        # converts output into String(Boolean) and then can be compared to 'false'
        # if: ${{ !needs.changed-files.outputs.PRISMA_CHANGE }} == 'false'
        # or check if empty string '' meaning no value | ! operator doesn't work at step-level conditional
        if: needs.changed-files.outputs.PRISMA_CHANGE == ''
        run: |
          echo "running step for no db changes"

  vercel-deploy-pr-feat-dev:
    needs: pscale-create-branch-deploy-request
    # pull request is not yet merged && w/ db changes
    if: github.event.pull_request.merged == false && needs.pscale-create-branch-deploy-request.outputs.PRISMA_CHANGE
    environment: preview # Github Environment
    env:
      VERCEL_ENV: ${{ vars.VERCEL_ENV }}
      DEPLOY_REQUEST_NUM: ${{ needs.pscale-create-branch-deploy-request.outputs.DEPLOY_REQUEST_NUM }}
      PRISMA_DATABASE_URL: ${{ needs.pscale-create-branch-deploy-request.outputs.PSCALE_CONN_STRING }}
      PSCALE_CONN_STRING: ${{ needs.pscale-create-branch-deploy-request.outputs.PSCALE_CONN_STRING }}
      PSCALE_BRANCH_EXISTS: ${{ needs.pscale-create-branch-deploy-request.outputs.PSCALE_BRANCH_EXISTS }}
    outputs:
      GITHUB_HEAD_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}
      GITHUB_BASE_BRANCH: ${{ steps.extract_branch.outputs.GITHUB_BASE_BRANCH }}
    runs-on: ubuntu-latest
    steps:
      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment Variables
        run: vercel env pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Check Values after vercel env pull
        run: |
          echo "${DATABASE_URL}"
          echo "${NEXTAUTH_URL}"
          echo "${NEXTAUTH_SECRET}"
          echo "${VERCEL_URL}"
          echo "${VERCEL_ENV}"
          echo "https://{VERCEL_URL}"
          echo "https://${VERCEL_URL}"

        # Better to build in Vercel so that it has access to System Environment Variables and no need to define NEXTAUTH_URL
        # reference: https://next-auth.js.org/configuration/options

      - name: Extract branch name
        id: extract_branch
        # shell: bash
        run: |
          echo "check GITHUB_HEAD_BRANCH: ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
          echo "GITHUB_HEAD_BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT

          echo "check GITHUB_BASE_BRANCH: ${GITHUB_BASE_REF}"
          echo "GITHUB_BASE_BRANCH=${GITHUB_BASE_REF}" >> $GITHUB_OUTPUT

        # https://stackoverflow.com/questions/58033366/how-to-get-the-current-branch-within-github-actions

      - name: Display branches
        run: |
          echo "using GITHUB_HEAD_REF and GITHUB_REF: ${{ steps.extract_branch.outputs.GITHUB_HEAD_BRANCH }}"
          echo "using pull_request event: GITHUB_HEAD_REF: ${{ github.event.pull_request.head.sha }}"
          echo "using GITHUB_BASE_REF: ${{ steps.extract_branch.outputs.GITHUB_BASE_BRANCH }}"
          echo "using pull_request event: GITHUB_BASE_REF: ${{ github.event.pull_request.base.sha }}"

      - name: Add Env Vars to Preview Deployment on branch w/ opened PR
        run: |
          echo ${PRISMA_DATABASE_URL} >> db-url.txt
          cat db-url.txt
          vercel env add DATABASE_URL ${VERCEL_ENV} ${{ steps.extract_branch.outputs.branch }} < db-url.txt --token=${{ secrets.VERCEL_TOKEN }}

  # get pscale connection string of newly created branch on ffph_dev
  # prisma db push before creating deploy request (pscale still works even though deploy request created first before "db push" changes)
  # create deploy request

  # vercel env add DATABASE_URL for the branch (ffph_dev main if no changes | ffph_dev pr-refnum iw w/changes)
  # vercel deploy

  # without schema.prisma/db changes
  without-db-changes:
    needs: changed-files
    if: github.event.pull_request.merged == false && !needs.changed-files.outputs.PRISMA_CHANGE
    environment: preview # Github Environment
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "with db changes? ${{ needs.changed-files.outputs.PRISMA_CHANGE }}"
          echo "all changes: ${{ needs.changed-files.outputs.ALL_CHANGES }}"
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref): ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref): ${{ github.event.pull_request.base.ref }}"
          echo "Current Branch (head.sha): ${{ github.event.pull_request.head.sha }}"
          echo "Target Branch (base.sha): ${{ github.event.pull_request.base.sha }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
      - name: Install Planetscale CLI
        run: |
          echo "installing planetscale cli"

  # on approved pr and merged branch into dev
  # approve deploy request
  # delete pr branch

  pscale-merge-pr-branch-approve-deploy-request:
    if: github.event.pull_request.merged == true
    environment: preview
    env:
      PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
      PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
      PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Env Values
        run: |
          echo "GITHUB_PR_REFNUM: ${GITHUB_PR_REFNUM}"
          echo "GITHUB_PR_TITLE ${GITHUB_PR_TITLE}"
          echo "VERCEL_ORG_ID ${VERCEL_ORG_ID}"
          echo "VERCEL_PROJECT_ID ${VERCEL_PROJECT_ID}"
          echo "PSCALE_SRC_BRANCH ${PSCALE_SRC_BRANCH}"
          echo "PLANETSCALE_SERVICE_TOKEN_ID ${PLANETSCALE_SERVICE_TOKEN_ID}"
          echo "PLANETSCALE_SERVICE_TOKEN ${PLANETSCALE_SERVICE_TOKEN}"
          echo "PSCALE_DB_NAME ${PSCALE_DB_NAME}"
          echo "Current Branch (head.ref) pull_request: ${{ github.event.pull_request.head.ref }}"
          echo "Target Branch (base.ref) pull_request: ${{ github.event.pull_request.base.ref }}"
          echo "PR merged? ${{ github.event.pull_request.merged }}"
          echo "PR state? ${{ github.event.pull_request.state }}"
      - name: Approve Pscale Deploy Request
        run: |
          echo "Pull Request has been merged into Github Dev Branch"
          echo "approving pscale deploy request from pr branch into main branch on ffph_dev db"
      - name: Delete Pscale ffph_dev pr branch
        run: |
          echo "Deleting pr branch on ffph_dev db"

          # vercel-deploy-feat-with-opened-pr:
          #   environment: preview
          #   runs-on: ubuntu-latest
          #   steps:
          #     - name: Check Env Values
          #       run: |
          #         echo ${GITHUB_PR_REFNUM}
          #         echo ${GITHUB_PR_TITLE}
          #         echo ${VERCEL_ORG_ID}
          #         echo ${VERCEL_PROJECT_ID}
          #         echo ${PSCALE_SRC_BRANCH}
          #     - name: Get code
          #       uses: actions/checkout@v3
          #     - name: Cache dependencies
          #       id: cache
          #       uses: actions/cache@v3
          #       with:
          #         path: ./node_modules
          #         key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
          #     - name: Install dependencies
          #       if: steps.cache.outputs.cache-hit != 'true'
          #       run: npm ci
          #     - name: Install Vercel CLI
          #       run: npm install --global vercel@latest
          #     # - name: Pull Vercel Environment Information
          #     #   run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
          #     # - name: Check Values after vercel env pull
          #     #   run: |
          #     #     echo "${DATABASE_URL}"
          #     #     echo "${NEXTAUTH_URL}"
          #     #     echo "${NEXTAUTH_SECRET}"
          #     #     echo $VERCEL_URL
          #     #     echo "${VERCEL_URL}"
          #     #     echo "${VERCEL_ENV}"
          #     #     echo "https://{VERCEL_URL}"
          #     #     echo "https://${VERCEL_URL}"
          #     # Better to build in Vercel so that it has access to System Environment Variables and no need to define NEXTAUTH_URL
          #     # reference: https://next-auth.js.org/configuration/options
          #     # - name: Build Project Artifacts
          #     #   run: npm run postinstall && vercel build --token=${{ secrets.VERCEL_TOKEN }}
          #     - name: Deploy Project to Vercel
          #       run: |
          #         vercel deploy --token=${{ secrets.VERCEL_TOKEN }} >deployment-url.txt 2>error.txt
          #         bash ./shell-scripts/vercel/check-deploy.sh
          #       # vercel deploy --token=${{ secrets.VERCEL_TOKEN }} > deployment-url.txt
          #       # echo "env.VERCEL_ENV ${{ env.VERCEL_ENV }}"
          #       # NEXTAUTH will produce error after deployment if using "vercel deploy --prebuilt", since VERCEL_URL (deployment url) not yet known during build step (previous step)
          #       # can only get VERCEL_URL after deploy
          #       # run: vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }}
          #     # - name: Extract branch name
          #     #   id: extract_branch
          #     #   # shell: bash
          #     #   run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
          #     #   # https://stackoverflow.com/questions/58033366/how-to-get-the-current-branch-within-github-actions
          #     # - name: Add Env Var to Preview Deployment on branch w/ opened PR
          #     #   run: |
          #     #     echo ${{ steps.extract_branch.outputs.branch }}
          #     #     vercel env add NEXTAUTH_URL preview ${{ steps.extract_branch.outputs.branch }} < deployment-url.txt --token=${{ secrets.VERCEL_TOKEN }}
          #     # remove env variable if already exists for branch
          #     # vercel env rm --yes NEXTAUTH_URL ${{ env.VERCEL_ENV }} ${{ steps.extract_branch.outputs.branch }} --token=${{ secrets.VERCEL_TOKEN }}
          #     # run: vercel env add [env-name] [environment=preview] [gitbranch=gh-actions-vars] < file
          #     # ref: https://vercel.com/docs/cli/env
          #     # need a bash script to check if NEXTAUTH_URL already defined for preview pr branch, then remove it if present otherwise proceed directly to adding it

          # # pscale create  branch: pr-refnum | on db: ffph_dev | uname: fractionfitness2021-bak
          # # pscale deploy request
          # # pscale get connection string and use in vercel deployment of feat-refnum-*

          # vercel-deploy-dev-after-merged-pr:
          #   if: github.event.pull_request.merged == true
          #   environment: preview
          #   needs: pscale-merge-pr-branch
          #   runs-on: ubuntu-latest
          #   steps:
          #     - name: Check Env Values
          #       run: |
          #         echo ${GITHUB_PR_REFNUM}
          #         echo ${GITHUB_PR_TITLE}
          #         echo ${VERCEL_ORG_ID}
          #         echo ${VERCEL_PROJECT_ID}
          #         echo ${PSCALE_SRC_BRANCH}
          #     - name: Get code
          #       uses: actions/checkout@v3
          #     - name: Cache dependencies
          #       id: cache
          #       uses: actions/cache@v3
          #       with:
          #         path: ./node_modules
          #         key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
          #     - name: Install dependencies
          #       if: steps.cache.outputs.cache-hit != 'true'
          #       run: npm ci
          #     - name: Install Vercel CLI
          #       run: npm install --global vercel@latest
          #     - name: Deploy Project to Vercel
          #       run: |
          #         vercel deploy --token=${{ secrets.VERCEL_TOKEN }} >deployment-url.txt 2>error.txt
          #         bash ./shell-scripts/vercel/check-deploy.sh

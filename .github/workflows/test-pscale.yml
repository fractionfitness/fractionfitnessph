name: Test Pscale Workflow

on:
  # to manually trigger if I somehow missed an activity type
  workflow_dispatch:
  pull_request:
    # branches: [feat/no-ref/cicd-setup, test-pr]
    branches: [dev]
    types:
      [
        opened,
        synchronize,
        edited,
        reopened,
        ready_for_review,
        unlocked,
        review_requested,
        closed,
      ]
  # push:
  #   branches: [test-workflows, test-*-workflows]

env:
  GITHUB_PR_TITLE: ${{ github.event.pull_request.title }}

  # PSCALE_BRANCH_NAME: 'pr-31-cicd-test'
  # PSCALE_PWORD_NAME: 'pr-31-admin'

jobs:
  # download scripts
  # ls -al
  # chmod
  # upload artifacts

  # change this to prep: upload scripts, check if w/ db changes, check if branch password & cache exists

  # probably can use cache instead of scripts but how can you check if there are changes to these files > check changed files if any script is included
  #  may not be worth it to use cache since not that many files

  pushed-commits-to-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check DB changes since last Push to opened Pull Request
        continue-on-error: true
        id: db_changes_on_push
        run: |
          COMMIT_AFTER_PUSH=${{ github.event.after }}
          COMMIT_PRIOR_PUSH=${{ github.event.before }}

          DB_CHANGES=$(eval "git diff --name-only --diff-filter=ACMRT $COMMIT_AFTER_PUSH $COMMIT_PRIOR_PUSH | grep -w schema.prisma$")

          if [ DB_CHANGES != 'null' ]; then
            DB_CHANGED_SINCE_LAST_PUSH='true'
          else
            DB_CHANGED_SINCE_LAST_PUSH='false'
          fi

          echo "DB_CHANGED_SINCE_LAST_PUSH: ${DB_CHANGED_SINCE_LAST_PUSH}"
          echo "DB_CHANGED_SINCE_LAST_PUSH=${DB_CHANGED_SINCE_LAST_PUSH}" >> "${GITHUB_OUTPUT}"
      - name: das
        run: |
          echo "check: ${{ steps.db_changes_on_push.outputs.DB_CHANGED_SINCE_LAST_PUSH }}"

        # echo "pull_request ${{ github.event.pull_request }}"
        # echo "event ${{ github.event }}"

#   upload-scripts:
#     environment: preview
#     runs-on: ubuntu-latest
#     env:
#       PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
#       PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
#     steps:
#       - name: Checkout repository
#         uses: actions/checkout@v3
#       - name: Upload shell scripts as Artifact
#         uses: actions/upload-artifact@v3
#         with:
#           name: scripts
#           if-no-files-found: error
#           path: |
#             ./.pscale/cli-helper-scripts
#             ./my-scripts/

#       # Permission Loss: File permissions are not maintained during artifact upload. For example, if you make a file executable using chmod and then upload that file, post-download the file is no longer guaranteed to be set as an executable.

#       # - name: Test executing one authenticate-ps.sh
#       #   continue-on-error: true
#       #   run: |
#       #     ls -al ./.pscale/cli-helper-scripts/
#       #     echo "------------------------------------------"
#       #     chmod -R +x ./.pscale/cli-helper-scripts/
#       #     echo "after chmod"
#       #     ls -al ./.pscale/cli-helper-scripts/
#       #     echo "------------------------------------------"
#       #     ./.pscale/cli-helper-scripts/authenticate-ps.sh

#       # authenticate-ps.sh just executes Planetscale login prompt if Planetscale service token and id not set as env
#       # dont need to use authenticate-ps.sh since already have setup-pscale-action

#   create-branch-pword-dr:
#     if: github.event_name == 'push'
#     needs: upload-scripts
#     runs-on: ubuntu-latest
#     environment: preview
#     env:
#       PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
#       PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
#       PSCALE_DB_NAME: ${{ vars.PSCALE_DB_NAME }}
#       PSCALE_PWORD_ROLE: ${{ vars.PSCALE_PWORD_ROLE }}
#       PSCALE_SRC_BRANCH: ${{ vars.PSCALE_SRC_BRANCH }}
#       PSCALE_ORG_NAME: ${{ vars.PSCALE_ORG_NAME }}
#     steps:
#       - name: Download scripts artifact
#         uses: actions/download-artifact@v3
#         with:
#           name: scripts
#           path: ./

#       #  different github branch name based on event (push vs. pull_request)
#       # Pscale Branch Name is based on Github Branch Name and PR ref number
#       - name: Get Pscale Branch Name
#         id: branch_name
#         working-directory: ./my-scripts/pscale/
#         shell: bash
#         run: |
#           chmod -R +x ./

#           GITHUB_BRANCH_NAME="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
#           GITHUB_PR_NUMBER=${{ github.event.pull_request.number }}

#           echo "GITHUB_BRANCH_NAME based on ref: ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"

#           ./get-pscale-branch-name.sh $GITHUB_BRANCH_NAME $GITHUB_PR_NUMBER

#           echo "outputs: PSCALE_BRANCH_NAME"

#         # echo "GITHUB_BRANCH_NAME based on push event: ${{ github.event.push.ref}}"

#       - name: Create Pscale Branch
#         uses: planetscale/create-branch-action@v4
#         id: create_branch
#         with:
#           org_name: ${{ env.PSCALE_ORG_NAME}}
#           database_name: ${{ env.PSCALE_DB_NAME}}
#           branch_name: ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}
#           from: ${{ env.PSCALE_SRC_BRANCH }}
#           wait: true
#           check_exists: true

#       # CONTINUE: insert Create Deploy Request here or in a separate job after creating branch and password

#       # step (Delete Branch Password) needs this
#       - name: Planetscale Setup
#         uses: planetscale/setup-pscale-action@v1

#       # can possibly move this to job: prep
#       - name: Get Branch Password if exists
#         id: existing_pword
#         shell: bash
#         working-directory: ./my-scripts/pscale/
#         run: |
#           PSCALE_BRANCH_NAME=${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME }}
#           PSCALE_PWORD_NAME=${PSCALE_BRANCH_NAME}-${PSCALE_PWORD_ROLE}

#           ./get-pword-info.sh ${{ env.PSCALE_DB_NAME }} ${PSCALE_BRANCH_NAME} ${{ env.PSCALE_ORG_NAME }} ${PSCALE_PWORD_NAME}

#           echo "outputs: EXISTING_PWORD_ID | EXISTING_PWORD_NAME"

#       # PWORD_ID=`pscale password list ${{ env.PSCALE_DB_NAME }} ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME }} --org ${{ env.PSCALE_ORG_NAME }} --format json | jq -r "[.[] | select(.name == \"${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}-${PSCALE_PWORD_ROLE}\") ] | .[0].id "`

#       # if [ "${output}" != 'null' ]; then
#       #   export EXISTING_PWORD_ID="${PWORD_ID}"
#       # fi

#       # echo "EXISTING_PWORD_ID=${EXISTING_PWORD_ID}" >> $GITHUB_OUTPUT

#       # echo "EXISTING_PWORD_ID: ${EXISTING_PWORD_ID}"

#       # can possibly move this to job: prep
#       # only check cache (not downloaded), if an existing password exists in planetscale
#       - name: Check if Cache exists for Branch Password
#         if: steps.existing_pword.outputs.EXISTING_PWORD_ID != 'null'
#         id: check_cache_pword
#         uses: actions/cache/restore@v3
#         with:
#           path: ./branch-conn-string.txt
#           key: ${{ steps.existing_pword.outputs.EXISTING_PWORD_NAME }}-${{ steps.existing_pword.outputs.EXISTING_PWORD_ID }}
#           lookup-only: true

#       # download cached pscale branch conn string file
#       - name: Get Branch Connection String from Cache Hit
#         if: steps.check_cache_pword.outputs.cache-hit == 'true'
#         uses: actions/cache/restore@v3
#         with:
#           path: ./branch-conn-string.txt
#           key: ${{ steps.existing_pword.outputs.EXISTING_PWORD_NAME }}-${{ steps.existing_pword.outputs.EXISTING_PWORD_ID }}

#       # delete if password exists & cache miss
#       - name: Delete Branch Password if exists & cache miss
#         if: steps.existing_pword.outputs.EXISTING_PWORD_ID != 'null' && steps.check_cache_pword.outputs.cache-hit != 'true'
#         working-directory: ./my-scripts/pscale
#         shell: bash
#         run: |
#           echo "pword id: ${{ steps.existing_pword.outputs.EXISTING_PWORD_ID }}"
#           export PSCALE_PWORD_NAME=${{ steps.existing_pword.outputs.EXISTING_PWORD_NAME }}
#           export PSCALE_BRANCH_NAME=${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}

#           . ./delete-branch-password.sh

#           delete-branch-password ${PSCALE_DB_NAME} ${PSCALE_BRANCH_NAME} ${PSCALE_ORG_NAME} ${PSCALE_PWORD_NAME}

#       # create if nonexistent password or cache miss
#       - name: Create Branch Password
#         if: steps.existing_pword.outputs.EXISTING_PWORD_ID == 'null' || steps.check_cache_pword.outputs.cache-hit != 'true'
#         id: create_pword
#         uses: planetscale/create-branch-password-action@v3
#         with:
#           org_name: ${{ env.PSCALE_ORG_NAME }}
#           database_name: ${{ env.PSCALE_DB_NAME }}
#           branch_name: ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME }}
#           name: ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}-${PSCALE_PWORD_ROLE}

#       # if: steps.check_cache_pword.outputs.cache-hit != 'true'
#       - name: Get Created Branch Credentials
#         id: credentials
#         if: steps.create_pword.outcome == 'success'
#         env:
#           HOSTNAME: ${{ steps.create_pword.outputs.hostname }}
#           USERNAME: ${{ steps.create_pword.outputs.username }}
#           PASSWORD: ${{ steps.create_pword.outputs.password }}
#         shell: bash
#         working-directory: ./my-scripts/pscale/
#         run: |
#           echo "mysql://${USERNAME}:${PASSWORD}@${HOSTNAME}/${PSCALE_DB_NAME}?sslaccept=strict" | tee -a "../../branch-conn-string.txt"

#           PSCALE_BRANCH_NAME=${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME }}
#           PSCALE_PWORD_NAME=${PSCALE_BRANCH_NAME}-${PSCALE_PWORD_ROLE}

#           ./get-pword-info.sh ${{ env.PSCALE_DB_NAME }} ${PSCALE_BRANCH_NAME} ${{ env.PSCALE_ORG_NAME }} ${PSCALE_PWORD_NAME}

#           echo "outputs: EXISTING_PWORD_ID | EXISTING_PWORD_NAME"

#         # CREATED_PWORD_ID=`pscale password list ${{ env.PSCALE_DB_NAME }} ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME }} --org ${{ env.PSCALE_ORG_NAME }} --format json | jq -r "[.[] | select(.name == \"${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}-${PSCALE_PWORD_ROLE}\") ]  | .[0].id "`

#         # echo "CREATED_PWORD_ID=${CREATED_PWORD_ID}" >> $GITHUB_OUTPUT

#         # echo "check here---------------------------------"
#         # if [ ${{ steps.create_pword.outputs.password }} != 'null' ]; then
#         #   echo "password: ${{ steps.create_pword.outputs.password }}"
#         # fi
#         # echo "password: ${{ steps.create_pword.outputs.password }}"
#         # echo "-------------------------------------------"

#         # "tee -a" appends value to multiple files
#         # cannot set secret as output as github actions will mask it with ****
#         # if appending to multiple files
#         # echo "${PSCALE_CONN_STRING}" | tee -a "${GITHUB_OUTPUT}" "branch-conn-string.txt"

#       # - name: Check step
#       #   run: |
#       #     echo "OUTCOME ${{ steps.create_pword.outcome }}"
#       #     echo "PASSWORD ${{ steps.create_pword.outputs.password }}"
#       #     echo "HOSTNAME ${{ steps.create_pword.outputs.hostname }}"
#       #     echo "USERNAME ${{ steps.create_pword.outputs.username }}"

#       # upload cached pscale branch conn string file for use in succeeding steps or jobs
#       # no need to restore since on the next workflow run, there will be a cache hit and there will be no new branch conn string, that is generated, to upload
#       # if: steps.check_cache_pword.outputs.cache-hit != 'true'
#       - name: Cache newly created Branch Connection String on Cache Miss
#         if: steps.create_pword.outcome == 'success'
#         uses: actions/cache/save@v3
#         with:
#           path: ./branch-conn-string.txt
#           key: ${{ steps.credentials.outputs.EXISTING_PWORD_NAME}}-${{ steps.credentials.outputs.EXISTING_PWORD_ID }}

#       # parse branch conn string from file for use in succeeding steps
#       - name: Output Database Url from Branch connection string
#         id: db_url
#         run: |
#           DATABASE_URL=$(eval "cat ./branch-conn-string.txt")

#           echo "DATABASE_URL=${DATABASE_URL}" >> ${GITHUB_OUTPUT}

#       # used for checking conn string if it coincides with pscale value
#       # no need to implement artifacts to store branch conn string
#       - name: Upload Branch Connection String
#         uses: actions/upload-artifact@v3
#         with:
#           name: ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}-${{ env.PSCALE_PWORD_ROLE }}
#           path: ./branch-conn-string.txt

#       - name: Check if Open Deploy Request exists for Branch
#         id: existing_dr
#         working-directory: ./my-scripts/pscale/
#         env:
#           PSCALE_BRANCH_NAME: ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME}}
#         run: |
#           ./check-dr-exists.sh "${PSCALE_DB_NAME}" "${PSCALE_BRANCH_NAME}" "${PSCALE_ORG_NAME}"

#           echo "step outputs: DR_EXISTS | DR_NUMBER | DR_BRANCH | DR_INTO_BRANCH | DR_APPROVED | DR_STATE | DR_DEPLOY_STATE | DR_DEPLOYABLE"

#       # only runs when no existing DR OR if it exists, its state='closed'
#       - name: Create Deploy Request
#         if: steps.existing_dr.outputs.DR_EXISTS == 'false' || steps.existing_dr.outputs.DR_STATE == 'closed'
#         id: create_dr
#         uses: planetscale/create-deploy-request-action@v2
#         with:
#           org_name: ${{ env.PSCALE_ORG_NAME }}
#           database_name: ${{ env.PSCALE_DB_NAME }}
#           branch_name: ${{ steps.branch_name.outputs.PSCALE_BRANCH_NAME }}
#           deploy_to: ${{ env.PSCALE_SRC_BRANCH }}

#       - name: Get Current Deploy Request Number
#         id: deploy_request
#         run: |
#           EXISTING_DR_NUMBER=${{ steps.existing_dr.outputs.DR_NUMBER }}
#           EXISTING_DR_STATE=${{ steps.existing_dr.outputs.DR_STATE }}
#           CREATED_DR_NUMBER=${{ steps.create_dr.outputs.number }}

#           echo "tests---------------------------------------------------"
#           echo "EXISTING_DR_NUMBER: ${EXISTING_DR_NUMBER}"
#           echo "EXISTING_DR_STATE: ${EXISTING_DR_STATE}"

#           echo "CREATED_DR_NUMBER: ${CREATED_DR_NUMBER}"
#           echo "tests---------------------------------------------------"

#           if [ -n "${CREATED_DR_NUMBER}" ]; then
#             echo "DR_NUMBER: ${CREATED_DR_NUMBER}"
#           elif [[ -n "${EXISTING_DR_NUMBER}" && "${EXISTING_DR_STATE}" == "open" ]]; then
#             echo "DR_NUMBER: ${EXISTING_DR_NUMBER}"
#           else
#             echo "Error: No Deploy Request found or created for the Planetscale Branch."
#             exit 1
#           fi

#         # alternative condition check: if DR exists and state='open'
#         # if [ -n $EXISTING_DR_NUMBER && EXISTING_DR_STATE == 'open' ]; then
#         #   echo "DR_NUMBER: ${{ steps.existing_dr.outputs.DR_NUMBER }}"
#         # else
#         #   echo "DR_NUMBER: ${{ steps.create_dr.outputs.number }}"
#         # fi

#         # alternative to double bracket conditional
#         # elif [ -n "${EXISTING_DR_NUMBER}" -a "${EXISTING_DR_STATE}" == "open" ]; then

#   # Deploy Deploy Request
#   deploy-dr:
#     if: github.event_name == 'pull_request'
#     needs: upload-scripts
#     runs-on: ubuntu-latest
#     environment: preview
#     env:
#       PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
#       PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
#     steps:
#       - name: Download scripts artifact
#         uses: actions/download-artifact@v3
#         with:
#           name: scripts
#           path: ./

#       - name: Make scripts excutable
#         working-directory: ./.pscale/cli-helper-scripts/
#         run: chmod -R +x ./

#         # "chmod -R +x ." needed since upload-artifact action results in Permission Loss (files won't be executable), even if they were executable when committed to repo

#       - name: Planetscale Setup
#         uses: planetscale/setup-pscale-action@v1
#       - name: Retrieve branch if exists
#         id: get_branch
#         working-directory: ./.pscale/cli-helper-scripts/
#         run: |
#           . ./ps-create-helper-functions.sh
#           create-deploy-request-info "$PSCALE_DB_NAME" "$PSCALE_ORG_NAME" 44
#           echo "Step Outputs: BRANCH_NAME / DB_NAME ORG_NAME / DEPLOY_REQUEST_URL / DEPLOY_REQUEST_NUMBER / BRANCH_URL"

#       # . ./use-pscale-docker-image.sh
#       # echo "in github runner / retrieve step / BRANCH_NAME: ${BRANCH_NAME}"

#       # doesn't work since env vars not shared between steps
#       # - name: Export this deploy request's branch as Env Variable
#       #   run: |
#       #     echo "in github runner / export step not using outputs / BRANCH_NAME: ${BRANCH_NAME}"

#       # this step is not required since we can just go direct to deployment if deploy-request exists
#       # - name: Check if Deploy Request exists
#       #   working-directory: ./.pscale/cli-helper-scripts/
#       #   run: |
#       #     BRANCH_NAME=${{ steps.get_branch.outputs.BRANCH_NAME }}
#       #     echo "in github runner / check DR step / BRANCH_NAME: ${BRANCH_NAME}"
#       #     . ./retrieve-deploy-request-info.sh
#       #     retrieve-deploy-request-info ${PSCALE_DB_NAME} ${PSCALE_ORG_NAME} ${PSCALE_DR_NUM}

#       # it's not obvious here since not passed as an argument, but retrieve-deploy-request-info.sh requires an env variable named BRANCH_NAME
#       # no need to export BRANCH_NAME to be useable inside of retrieve-deploy-request-info.sh

#       - name: Deploy deploy request
#         uses: planetscale/deploy-deploy-request-action@v3
#         with:
#           org_name: ${{ env.PSCALE_ORG_NAME }}
#           database_name: ${{ env.PSCALE_DB_NAME }}
#           number: 45
#           wait: true
# # check if DR exists - no need???

# # approve DR before deploy

# # get the dr for the branch, so you can check for the ff

# # get the DR num based on the branch

# # can check if it DR is open so that we can proceed with the deploy, because if it isnt open, it means previous DR was closed/rejected, a new DR needs to be created and approved, and TL missed reviewing the db changes before the PR merge/approval

# # check if issue-ops-ps-command /ps-merge, merge-deploy-request.sh, ps-create-helper-functions create-deployment and any other code, checks if DEPLOY_STATE=ready, DEPLOYABLE=YES, etc.

# # if it is closed, don't proceed with the deployment and prompt that a new DR needs to be created and reviewed

# # possibly only need to check STATE when getting the DR to see if the last DR is open/closed but Deploy step will fail if last DR is closed so does it matter checking the STATE?

# # check if you can hijack the job in the issue-ops-ps-commands.yml and reuse in your own workflow for merge deploy, etc.

# # workflow fails if DEPLOY_STATE=no_changes even if APPROVED=Yes & DEPLOYABLE=Yes

# # if no db changes, delete branch

# # if deploy-deploy-request-action is set with "wait: true" and auto-apply is disabled (gated deployment), this error occurs: Deploy-request 44 with unknown status: 'pending_cutover'
# # script doesnt take into account pending_cutover coz its indefinite when approver will apply the changes (gated deployments)

# # deploy-deploy-request-action fails when deployment has been applied but schema revert is still active (DEPLOY_STATE='complete_pending_revert', STATE=open, APPROVED=Yes, DEPLOYABLE=yes) / this must be because it is functionally merged with pscale main branch

# # "gated deployments" and "schema revert" features are still experimental

# # enable gated deployments (--auto-apply 'disabled' for pr merges with main and deploy requests to ffph_prod main

# # how do we get the Deploy Request Number?
# # start tracing it from merge-deploy-request.sh, merge-latest-open-deploy-request.sh and issue-ops-ps-commands /ps-merge

# # if the created branch already has a latest open DR (STATE=open), prevent creating new DR | already the default behavior of Pscale

# # once a deploy request has been merged and schema-revert period has lapsed, delete the branch immediately, to prevent problems with tracking db changes and feat-branches. one branch should correspond to only one DR with the ff: DEPLOY_STATE=complete, STATE=closed, APPROVED=Yes

# # delete branch after applying changes and even before schema-revert has lapsed | let skip-revert time-out just in case you need to revert changes | no need to skip-revert since branch will be closed anyway and no new DRs can be created while STATE=open for DEPLOY_STATE=complete_pending_revert

# # if schema-revert is performed, corresponding branch merge into dev should be reverted but how is this done?

# # if you close a pr, pscale branch should also automatically be deleted

# # prioritize gh actions for creating branch, password, deploy request, deploying DR, deleting branch (manually/automated)
